# Анализ алгоритмической сложности реализованных решений:
## 1. GeneratePresetImpl.generate()
   
Что делает: Формирует армию компьютера, выбирая юнитов с лучшим соотношением атаки к стоимости.

Алгоритмическая сложность:

    Сортировка юнитов: O(k log k) где k = 4 (количество типов юнитов) - фактически O(1)
    Основной цикл: проходит по каждому типу и добавляет до 11 юнитов - O(11 * 4) = O(44) = O(1)
    Итоговая сложность: O(1), что лучше требуемой O(n*m) где n=4, m=1500/минимальная_стоимость

## 2. SimulateBattleImpl.simulate()

Что делает: Проводит пошаговый бой, сортируя юнитов по атаке каждый раунд.

Алгоритмическая сложность:

    В худшем случае: R раундов × (сбор живых O(N) + сортировка O(N log N) + обход O(N))
    Где N = общее количество юнитов (до ~100)
    Итоговая сложность: O(R * N log N)
    При максимальном количестве раундов R ≈ N, получаем O(N² log N), что соответствует требованию

## 3. SuitableForAttackUnitsFinderImpl.getSuitableUnits()

Что делает: Находит юнитов, не закрытых соседями для атаки.

Алгоритмическая сложность:

    3 ряда × M юнитов в ряду
    Для каждого юнита проверка наличия соседа: O(1) через HashSet
    Итоговая сложность: O(3 * M) = O(M) = O(N), где N - общее число юнитов
    Соответствует требованию O(n*m) с m=3 → O(3n) = O(n)

## 4. UnitTargetPathFinderImpl.getTargetPath()

Что делает: Находит кратчайший путь с помощью BFS на сетке 27×21.

Алгоритмическая сложность:

    Размер поля: V = WIDTH × HEIGHT = 27 × 21 = 567 вершин
    BFS посещает каждую вершину максимум 1 раз: O(V)
    Проверка 8 соседей для каждой вершины: O(8V) = O(V)
    Итоговая сложность: O(V) = O(567) = O(1) константа
    Если рассматривать как O(W×H), то соответствует требованию O(W×H log(W×H))